/**
 * API routes for agents
 */

import { createRouter, validator } from '@agentuity/runtime';
import { s } from '@agentuity/schema';
import translate, { AgentOutput, type HistoryEntry } from '../agent/translate';
import manager from '../agent/manager';
import contentCreator from '../agent/content-creator';
import videoEditor from '../agent/video-editor';
import grantWriter from '../agent/grant-writer';
import donorResearcher from '../agent/donor-researcher';
import venueProspector from '../agent/venue-prospector';
import { sendToMakeWebhook, getConfiguredWebhooks } from '../agent/content-creator/webhooks';
import { createDriveProxyToken, verifyDriveProxyToken } from '../agent/video-editor/drive-proxy';

const api = createRouter();

// State subset for history endpoints (derived from AgentOutput)
export const StateSchema = AgentOutput.pick(['history', 'threadId', 'translationCount']);

// Translation agent
api.post('/translate', translate.validator(), async (c) => {
	const data = c.req.valid('json');
	return c.json(await translate.run(data));
});

// Retrieve translation history
api.get('/translate/history', validator({ output: StateSchema }), async (c) => {
	const history = (await c.var.thread.state.get<HistoryEntry[]>('history')) ?? [];
	return c.json({
		history,
		threadId: c.var.thread.id,
		translationCount: history.length,
	});
});

// Clear translation history
api.delete('/translate/history', validator({ output: StateSchema }), async (c) => {
	await c.var.thread.state.delete('history');
	return c.json({
		history: [],
		threadId: c.var.thread.id,
		translationCount: 0,
	});
});

// Manager agent
api.post('/manager', manager.validator(), async (c) => {
	const data = c.req.valid('json');
	return c.json(await manager.run(data));
});

// Content creator agent
api.post('/content-creator', contentCreator.validator(), async (c) => {
	const data = c.req.valid('json');
	return c.json(await contentCreator.run(data));
});

// Video editor agent
api.post('/video-editor', videoEditor.validator(), async (c) => {
	const data = c.req.valid('json');
	// Build the public-facing origin for Shotstack proxy URLs.
	// The internal c.req.url uses *.agentuity.run.internal which external services can't resolve.
	// Priority: x-forwarded-host header > Origin header > Referer header > fallback to req.url
	const fwdHost = c.req.header('x-forwarded-host');
	const fwdProto = c.req.header('x-forwarded-proto') || 'https';
	let origin: string;
	if (fwdHost) {
		origin = `${fwdProto}://${fwdHost}`;
	} else {
		const originHeader = c.req.header('origin');
		const referer = c.req.header('referer');
		if (originHeader) {
			origin = originHeader;
		} else if (referer) {
			origin = new URL(referer).origin;
		} else {
			origin = new URL(c.req.url).origin;
		}
	}
	return c.json(await videoEditor.run({ ...data, appUrl: origin }));
});

// Google Drive file proxy — streams files for Shotstack to consume
// Secured with HMAC token so only URLs generated by the render task work
api.get('/drive-file/:fileId', async (c) => {
	const fileId = c.req.param('fileId');
	const token = c.req.query('token');

	if (!fileId || !token) {
		return c.text('Missing file ID or token', 400);
	}

	if (!verifyDriveProxyToken(fileId, token)) {
		return c.text('Invalid token', 403);
	}

	try {
		const { getAuth } = await import('../agent/video-editor/google-drive');
		const { drive_v3 } = await import('@googleapis/drive');

		const authClient = getAuth();
		const drive = new drive_v3.Drive({ auth: authClient });

		// Get file metadata for Content-Type and size
		const meta = await drive.files.get({
			fileId,
			fields: 'mimeType,size,name',
		});

		// Stream the file content
		const response = await drive.files.get(
			{ fileId, alt: 'media' },
			{ responseType: 'stream' },
		);

		const headers: Record<string, string> = {
			'Content-Type': meta.data.mimeType || 'video/mp4',
			'Cache-Control': 'public, max-age=3600',
		};
		if (meta.data.size) {
			headers['Content-Length'] = meta.data.size;
		}
		if (meta.data.name) {
			headers['Content-Disposition'] = `inline; filename="${meta.data.name}"`;
		}

		// Convert Node.js readable stream to Web ReadableStream for Response
		const nodeStream = response.data as NodeJS.ReadableStream;
		const { Readable } = await import('stream');
		const webStream = Readable.toWeb(Readable.from(nodeStream));

		return new Response(webStream as unknown as ReadableStream, {
			status: 200,
			headers,
		});
	} catch (err) {
		const msg = err instanceof Error ? err.message : String(err);
		console.error('[drive-file proxy] Error streaming file %s: %s', fileId, msg);
		return c.text('Failed to stream file: ' + msg, 500);
	}
});

// Pre-processed file proxy — serves FFmpeg-enhanced clips from .temp-cataloger/
// Same HMAC token approach as drive-file, but for locally pre-processed files
api.get('/processed-file/:processedId', async (c) => {
	const processedId = c.req.param('processedId');
	const token = c.req.query('token');

	if (!processedId || !token) {
		return c.text('Missing processed ID or token', 400);
	}

	if (!verifyDriveProxyToken(processedId, token)) {
		return c.text('Invalid token', 403);
	}

	try {
		const fs = await import('fs');
		const path = await import('path');

		// Security: only serve from the .temp-cataloger/ directory
		const tempDir = path.resolve(process.cwd(), '.temp-cataloger');
		const filePath = path.join(tempDir, `processed_${processedId}.mp4`);
		const resolvedPath = path.resolve(filePath);

		if (!resolvedPath.startsWith(tempDir)) {
			return c.text('Access denied', 403);
		}

		if (!fs.existsSync(resolvedPath)) {
			return c.text('Processed file not found', 404);
		}

		const stat = fs.statSync(resolvedPath);
		const stream = fs.createReadStream(resolvedPath);
		const { Readable } = await import('stream');
		const webStream = Readable.toWeb(stream as any);

		return new Response(webStream as unknown as ReadableStream, {
			status: 200,
			headers: {
				'Content-Type': 'video/mp4',
				'Content-Length': String(stat.size),
				'Cache-Control': 'public, max-age=3600',
				'Content-Disposition': `inline; filename="processed_${processedId}.mp4"`,
			},
		});
	} catch (err) {
		const msg = err instanceof Error ? err.message : String(err);
		console.error('[processed-file proxy] Error streaming file %s: %s', processedId, msg);
		return c.text('Failed to stream processed file: ' + msg, 500);
	}
});

// Remotion render download — streams completed Remotion renders from .temp-cataloger/
// Keyed by render ID (format: remotion_<timestamp>_<random>)
api.get('/remotion-render/:renderId', async (c) => {
	const renderId = c.req.param('renderId');

	if (!renderId || !renderId.startsWith('remotion_')) {
		return c.text('Invalid render ID', 400);
	}

	try {
		const fs = await import('fs');
		const path = await import('path');

		// Security: only serve from the .temp-cataloger/ directory
		const tempDir = path.resolve(process.cwd(), '.temp-cataloger');
		const filePath = path.join(tempDir, `${renderId}.mp4`);
		const resolvedPath = path.resolve(filePath);

		if (!resolvedPath.startsWith(tempDir)) {
			return c.text('Access denied', 403);
		}

		if (!fs.existsSync(resolvedPath)) {
			return c.text('Render not found or not yet complete', 404);
		}

		const stat = fs.statSync(resolvedPath);
		const stream = fs.createReadStream(resolvedPath);
		const { Readable } = await import('stream');
		const webStream = Readable.toWeb(stream as any);

		return new Response(webStream as unknown as ReadableStream, {
			status: 200,
			headers: {
				'Content-Type': 'video/mp4',
				'Content-Length': String(stat.size),
				'Cache-Control': 'public, max-age=3600',
				'Content-Disposition': `inline; filename="${renderId}.mp4"`,
			},
		});
	} catch (err) {
		const msg = err instanceof Error ? err.message : String(err);
		console.error('[remotion-render] Error streaming render %s: %s', renderId, msg);
		return c.text('Failed to stream render: ' + msg, 500);
	}
});

// Grant writer agent
api.post('/grant-writer', grantWriter.validator(), async (c) => {
	const data = c.req.valid('json');
	return c.json(await grantWriter.run(data));
});

// Donor researcher agent
api.post('/donor-researcher', donorResearcher.validator(), async (c) => {
	const data = c.req.valid('json');
	return c.json(await donorResearcher.run(data));
});

// Venue prospector agent
api.post('/venue-prospector', venueProspector.validator(), async (c) => {
	const data = c.req.valid('json');
	return c.json(await venueProspector.run(data));
});

// Webhook: Send content to Make.com
export const WebhookInput = s.object({
	platform: s.string(),
	content: s.string(),
	imageUrl: s.string().optional(),
	imageStyle: s.string().optional(),
	scheduledTime: s.string().optional(),
});

api.post('/webhook/publish', validator({ input: WebhookInput }), async (c) => {
	const { platform, content, imageUrl, imageStyle, scheduledTime } = c.req.valid('json');
	const result = await sendToMakeWebhook(platform, content, imageUrl, imageStyle, scheduledTime);
	return c.json(result);
});

// Get configured webhooks
api.get('/webhook/config', async (c) => {
	const configured = getConfiguredWebhooks();
	return c.json({ configuredPlatforms: configured });
});

// --- Content Library ---

// Get all saved content
api.get('/content-library', async (c) => {
	const entries = (await c.var.thread.state.get<unknown[]>('content-library')) ?? [];
	return c.json({ entries, count: entries.length });
});

// Delete a specific library entry
api.delete('/content-library/:id', async (c) => {
	const id = c.req.param('id');
	const entries = (await c.var.thread.state.get<{ id: string }[]>('content-library')) ?? [];
	const filtered = entries.filter((e) => e.id !== id);

	if (filtered.length === entries.length) {
		return c.json({ success: false, error: 'Entry not found' }, 404);
	}

	await c.var.thread.state.set('content-library', filtered);
	return c.json({ success: true, remaining: filtered.length });
});

// --- Video Library ---

// Get all saved video renders
api.get('/video-library', async (c) => {
	const entries = (await c.var.thread.state.get<unknown[]>('video-library')) ?? [];
	return c.json({ entries, count: entries.length });
});

// Save a new video render entry (called from frontend on render completion)
api.post('/video-library', async (c) => {
	const entry = await c.req.json();
	if (!entry || !entry.id) {
		return c.json({ success: false, error: 'Invalid entry' }, 400);
	}
	await c.var.thread.state.push('video-library', entry, 100);
	return c.json({ success: true, id: entry.id });
});

// Delete a specific video library entry
api.delete('/video-library/:id', async (c) => {
	const id = c.req.param('id');
	const entries = (await c.var.thread.state.get<{ id: string }[]>('video-library')) ?? [];
	const filtered = entries.filter((e) => e.id !== id);

	if (filtered.length === entries.length) {
		return c.json({ success: false, error: 'Entry not found' }, 404);
	}

	await c.var.thread.state.set('video-library', filtered);
	return c.json({ success: true, remaining: filtered.length });
});

export default api;
